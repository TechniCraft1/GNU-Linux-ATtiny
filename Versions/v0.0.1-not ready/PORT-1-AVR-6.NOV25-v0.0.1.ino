//RISC-V GNU/LINUX
//The beginning to port this to the AVR
//by YVES
/*
TODOs:
-use UART instead of print/putchar/stdout
-use PROGMEM for dtb
-make mini-rv32ima AVR-friendly
-implement SPI (Read write to raw sd card)
-swap memory
-debug info
-memory efficent
-storage efficient
-port to AVR 16- archetecture (more store and memory efficiency smaller buffer read sector)
FINAL GOAL: ATtiny GNU/LINUX
*/
const unsigned char sixtyfourmb_dtb[] PROGMEM = {
  0xd0, 0x0d, 0xfe, 0xed, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x38,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x11,
  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3,
  0x00, 0x00, 0x04, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x1b,
  0x72, 0x69, 0x73, 0x63, 0x76, 0x2d, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61,
  0x6c, 0x2d, 0x6e, 0x6f, 0x6d, 0x6d, 0x75, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x26, 0x72, 0x69, 0x73, 0x63,
  0x76, 0x2d, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x61, 0x6c, 0x2d, 0x6e, 0x6f,
  0x6d, 0x6d, 0x75, 0x2c, 0x71, 0x65, 0x6d, 0x75, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x63, 0x68, 0x6f, 0x73, 0x65, 0x6e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x2c,
  0x65, 0x61, 0x72, 0x6c, 0x79, 0x63, 0x6f, 0x6e, 0x3d, 0x75, 0x61, 0x72,
  0x74, 0x38, 0x32, 0x35, 0x30, 0x2c, 0x6d, 0x6d, 0x69, 0x6f, 0x2c, 0x30,
  0x78, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2c, 0x31, 0x30,
  0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c,
  0x65, 0x3d, 0x74, 0x74, 0x79, 0x53, 0x30, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x01, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x40, 0x38,
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x35, 0x6d, 0x65, 0x6d, 0x6f,
  0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x01, 0x63, 0x70, 0x75, 0x73, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x45, 0x00, 0x0f, 0x42, 0x40,
  0x00, 0x00, 0x00, 0x01, 0x63, 0x70, 0x75, 0x40, 0x30, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x58,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x35, 0x63, 0x70, 0x75, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x60,
  0x6f, 0x6b, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1b, 0x72, 0x69, 0x73, 0x63,
  0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
  0x00, 0x00, 0x00, 0x67, 0x72, 0x76, 0x33, 0x32, 0x69, 0x6d, 0x61, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x71,
  0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x6e, 0x6f, 0x6e, 0x65, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70,
  0x74, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1b, 0x72, 0x69, 0x73, 0x63,
  0x76, 0x2c, 0x63, 0x70, 0x75, 0x2d, 0x69, 0x6e, 0x74, 0x63, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x58,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x01, 0x63, 0x70, 0x75, 0x2d, 0x6d, 0x61, 0x70, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63, 0x6f, 0x72, 0x65,
  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x01, 0x73, 0x6f, 0x63, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0f,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b,
  0x00, 0x00, 0x00, 0x1b, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x2d, 0x62,
  0x75, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x01, 0x75, 0x61, 0x72, 0x74,
  0x40, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xab,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1b, 0x6e, 0x73, 0x31, 0x36,
  0x38, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
  0x70, 0x6f, 0x77, 0x65, 0x72, 0x6f, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xbb,
  0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1b,
  0x73, 0x79, 0x73, 0x63, 0x6f, 0x6e, 0x2d, 0x70, 0x6f, 0x77, 0x65, 0x72,
  0x6f, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
  0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x77, 0x77,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xc1,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
  0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x1b, 0x73, 0x79, 0x73, 0x63,
  0x6f, 0x6e, 0x2d, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x73, 0x79, 0x73, 0x63,
  0x6f, 0x6e, 0x40, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x58,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x11, 0x10, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1b, 0x73, 0x79, 0x73, 0x63,
  0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
  0x63, 0x6c, 0x69, 0x6e, 0x74, 0x40, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
  0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03,
  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x1b,
  0x73, 0x69, 0x66, 0x69, 0x76, 0x65, 0x2c, 0x63, 0x6c, 0x69, 0x6e, 0x74,
  0x30, 0x00, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x63, 0x6c, 0x69, 0x6e,
  0x74, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x23, 0x61, 0x64, 0x64,
  0x72, 0x65, 0x73, 0x73, 0x2d, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x00, 0x23,
  0x73, 0x69, 0x7a, 0x65, 0x2d, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x00, 0x63,
  0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x00, 0x6d, 0x6f,
  0x64, 0x65, 0x6c, 0x00, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x72, 0x67, 0x73,
  0x00, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65,
  0x00, 0x72, 0x65, 0x67, 0x00, 0x74, 0x69, 0x6d, 0x65, 0x62, 0x61, 0x73,
  0x65, 0x2d, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x00,
  0x70, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x00, 0x73, 0x74, 0x61, 0x74,
  0x75, 0x73, 0x00, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2c, 0x69, 0x73, 0x61,
  0x00, 0x6d, 0x6d, 0x75, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x23, 0x69,
  0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x2d, 0x63, 0x65, 0x6c,
  0x6c, 0x73, 0x00, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74,
  0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x00,
  0x63, 0x70, 0x75, 0x00, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x00, 0x63,
  0x6c, 0x6f, 0x63, 0x6b, 0x2d, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e,
  0x63, 0x79, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x6f, 0x66, 0x66,
  0x73, 0x65, 0x74, 0x00, 0x72, 0x65, 0x67, 0x6d, 0x61, 0x70, 0x00, 0x69,
  0x6e, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x73, 0x2d, 0x65, 0x78,
  0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
unsigned int sixtyfourmb_dtb_len = 1536;


#define RAM_SIZE (64 * 1024 * 1024)
uint8_t *ram_image; // Must be global for macro use
struct MiniRV32IMAState *core;

// Declare hook functions BEFORE macro usage
static uint32_t HandleControlStore(uint32_t addr, uint32_t val);
static uint32_t HandleControlLoad(uint32_t addr);
static void HandleOtherCSRWrite(uint8_t *image, uint16_t csrno, uint32_t value);
static int32_t HandleOtherCSRRead(uint8_t *image, uint16_t csrno);
static uint64_t GetTimeMicroseconds();

// Now define macros
#define MINIRV32_RAM_IMAGE_OFFSET 0x80000000
#define MINIRV32WARN(x...) printf(x)
#define MINIRV32_DECORATE static
#define MINI_RV32_RAM_SIZE RAM_SIZE
#define MINIRV32_IMPLEMENTATION
#define MINIRV32_POSTEXEC(pc, ir, retval) \
    { if (retval > 0) retval = HandleControlStore(pc, retval); }
#define MINIRV32_HANDLE_MEM_STORE_CONTROL(addr, val) \
    if (HandleControlStore(addr, val)) return val;
#define MINIRV32_HANDLE_MEM_LOAD_CONTROL(addr, rval) \
    rval = HandleControlLoad(addr);
#define MINIRV32_OTHERCSR_WRITE(csrno, value) \
    HandleOtherCSRWrite(ram_image, csrno, value);
#define MINIRV32_OTHERCSR_READ(csrno, value) \
    value = HandleOtherCSRRead(ram_image, csrno);
#define MINIRV32_LOAD4(addr, rval) \
    rval = fetchWord(addr);
#define MINIRV32_STORE4(addr, val) \
    writeWord(addr, val);

// Now include the emulator
#include "mini-rv32ima.h" 
#include <SPI.h>
#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/delay.h> 
//---valid---//
#define RAM_SIZE (64 * 1024 * 1024)
//uint8_t *ram_image;
//struct MiniRV32IMAState *core;

static uint64_t GetTimeMicroseconds() { //valid
    return micros();
}

//SD init
#include <SPI.h>

#define CS_PIN 10

#include <avr/wdt.h>

void disableWatchdogEarly() __attribute__((naked)) __attribute__((section(".init3")));
void disableWatchdogEarly() {
  MCUSR = 0;
  WDTCSR |= (1 << WDCE) | (1 << WDE);
  WDTCSR = 0;
}

uint8_t ram_page[512];  // One sector buffer
uint32_t current_page = -1;
bool dirty = false;

void writeWord(uint32_t addr, uint32_t val) {
    loadPage(addr);
    uint16_t offset = (addr - MINIRV32_RAM_IMAGE_OFFSET) % 512;
    *(uint32_t*)&ram_page[offset] = val;
    dirty = true;
}

void loadPage(uint32_t addr) {
    uint32_t sector = (addr - MINIRV32_RAM_IMAGE_OFFSET) / 512;
    if (sector != current_page) {
        if (dirty) writeSectorToSD(current_page, ram_page);
        readSectorFromSD(sector, ram_page);
        current_page = sector;
        dirty = false;
    }
}

uint32_t fetchWord(uint32_t addr) {
         uint32_t sector = (addr - MINIRV32_RAM_IMAGE_OFFSET) / 512;
    if (sector != current_page) {
        Serial.print("Loading sector "); Serial.println(sector);
        if (dirty) writeSectorToSD(current_page, ram_page);
        readSectorFromSD(sector, ram_page);
        current_page = sector;
        dirty = false;
    }
    uint16_t offset = (addr - MINIRV32_RAM_IMAGE_OFFSET) % 512;
    return *(uint32_t*)&ram_page[offset];  
}

uint32_t fetchInstruction(uint32_t addr) {
    uint32_t sector = (addr - MINIRV32_RAM_IMAGE_OFFSET) / 512;
    uint16_t offset = (addr - MINIRV32_RAM_IMAGE_OFFSET) % 512;

    if (offset <= 508) {
        loadPage(addr);
        return *(uint32_t*)&ram_page[offset];
    } else {
        // Cross-sector fetch
        uint8_t temp[4];
        loadPage(addr);
        for (int i = 0; i < 512 - offset; i++) temp[i] = ram_page[offset + i];
        loadPage(addr + (512 - offset));
        for (int i = 512 - offset; i < 4; i++) temp[i] = ram_page[i - (512 - offset)];
        return *(uint32_t*)temp;
    }
}


//-----
bool initCard() {
  digitalWrite(CS_PIN, LOW);
  for (int i = 0; i < 10; i++) SPI.transfer(0xFF);  // Send dummy clocks

  sendCommand(0x40 | 0, 0, 0x95);  // CMD0
  if (waitForResponse() != 0x01) return false;

  sendCommand(0x40 | 8, 0x000001AA, 0x87);  // CMD8
  byte r = waitForResponse();
  if (r != 0x01) return false;

  // ACMD41 loop
  for (int i = 0; i < 100; i++) {
    sendCommand(0x40 | 55, 0, 0xFF);  // CMD55
    waitForResponse();
    sendCommand(0x40 | 41, 0x40000000, 0xFF);  // ACMD41
    r = waitForResponse();
    if (r == 0x00) break;
    delay(50);
  }

  digitalWrite(CS_PIN, HIGH);
  SPI.transfer(0xFF);
  return r == 0x00;
}



void readSector(uint32_t lba) {
  digitalWrite(CS_PIN, LOW);
  sendCommand(0x40 | 17, lba * 512, 0xFF);  // CMD17
  if (waitForResponse() == 0x00) {
    while (SPI.transfer(0xFF) != 0xFE);  // Wait for data token
    for (int i = 0; i < 512; i++) {
      byte b = SPI.transfer(0xFF);
      Serial.print(b, HEX); Serial.print(" ");
    }
    SPI.transfer(0xFF); SPI.transfer(0xFF);  // CRC
    Serial.println("\nSector read complete.");
  } else {
    Serial.println("Read failed.");
  }
  digitalWrite(CS_PIN, HIGH);
  SPI.transfer(0xFF);
}

void sendCommand(byte cmd, uint32_t arg, byte crc) {
  SPI.transfer(cmd);
  SPI.transfer(arg >> 24);
  SPI.transfer(arg >> 16);
  SPI.transfer(arg >> 8);
  SPI.transfer(arg);
  SPI.transfer(crc);
}

byte waitForResponse() {
  for (int i = 0; i < 8; i++) {
    byte r = SPI.transfer(0xFF);
    if (r != 0xFF) return r;
  }
  return 0xFF;
}

void writeSector(uint32_t lba) {
  byte buffer[512];
  for (int i = 0; i < 512; i++) buffer[i] = i;  // Fill with pattern

  digitalWrite(CS_PIN, LOW);
  sendCommand(0x40 | 24, lba * 512, 0xFF);  // CMD24
  if (waitForResponse() != 0x00) {
    Serial.println("Write command rejected.");
    digitalWrite(CS_PIN, HIGH);
    return;
  }

  SPI.transfer(0xFE);  // Data token
  for (int i = 0; i < 512; i++) SPI.transfer(buffer[i]);
  SPI.transfer(0xFF);  // Dummy CRC
  SPI.transfer(0xFF);

  byte response = SPI.transfer(0xFF);
  if ((response & 0x1F) == 0x05) {
    Serial.println("Write accepted.");
  } else {
    Serial.print("Write failed, response: ");
    Serial.println(response, HEX);
  }

  while (SPI.transfer(0xFF) == 0);  // Wait for card to finish
  digitalWrite(CS_PIN, HIGH);
  SPI.transfer(0xFF);
}


bool readSectorFromSD(uint32_t lba, uint8_t *buffer) {
  digitalWrite(CS_PIN, LOW);
  sendCommand(0x40 | 17, lba * 512, 0xFF);  // CMD17: READ_SINGLE_BLOCK

  if (waitForResponse() != 0x00) {
    digitalWrite(CS_PIN, HIGH);
    SPI.transfer(0xFF);
    return false;
  }

  // Wait for data token (0xFE)
  uint16_t timeout = 0xFFFF;
  while (SPI.transfer(0xFF) != 0xFE) {
    if (--timeout == 0) {
      digitalWrite(CS_PIN, HIGH);
      SPI.transfer(0xFF);
      return false;
    }
  }

  // Read 512 bytes into buffer
  for (int i = 0; i < 512; i++) {
    buffer[i] = SPI.transfer(0xFF);
  }

  // Discard CRC
  SPI.transfer(0xFF);
  SPI.transfer(0xFF);

  digitalWrite(CS_PIN, HIGH);
  SPI.transfer(0xFF);
  return true;
}
//end of SD functions
//emulator functions
static uint32_t HandleControlStore(uint32_t addr, uint32_t val) {
    if (addr == 0x10000000) Serial.write(val);
    else if (addr == 0x11004000) core->timermatchl = val;
    else if (addr == 0x11004004) core->timermatchh = val;
    else if (addr == 0x11100000) { core->pc += 4; return val; }
    return 0;
}

void preloadDTB(uint32_t dtb_addr) {
    for (int i = 0; i < sixtyfourmb_dtb_len; i++) {
        uint32_t addr = dtb_addr + i;
        loadPage(addr);
        ram_page[(addr % 512)] = pgm_read_byte(&sixtyfourmb_dtb[i]);
        dirty = true;
    }
}


bool writeSectorToSD(uint32_t lba, const uint8_t *buffer) {
  digitalWrite(CS_PIN, LOW);
  sendCommand(0x40 | 24, lba * 512, 0xFF);  // CMD24: WRITE_SINGLE_BLOCK

  if (waitForResponse() != 0x00) {
    digitalWrite(CS_PIN, HIGH);
    SPI.transfer(0xFF);
    return false;
  }

  SPI.transfer(0xFE);  // Data token

  for (int i = 0; i < 512; i++) {
    SPI.transfer(buffer[i]);
  }

  // Dummy CRC
  SPI.transfer(0xFF);
  SPI.transfer(0xFF);

  byte response = SPI.transfer(0xFF);
  if ((response & 0x1F) != 0x05) {
    digitalWrite(CS_PIN, HIGH);
    SPI.transfer(0xFF);
    return false;
  }

  // Wait for write completion
  while (SPI.transfer(0xFF) == 0);

  digitalWrite(CS_PIN, HIGH);
  SPI.transfer(0xFF);
  return true;
}


static uint32_t HandleControlLoad(uint32_t addr) {
    if (addr == 0x10000005) return 0x60;
    else if (addr == 0x1100bff8) return core->timerl;
    else if (addr == 0x1100bffc) return core->timerh;
    return 0;
}

static void HandleOtherCSRWrite(uint8_t *image, uint16_t csrno, uint32_t value) { //valid
    if (csrno == 0x136) Serial.print(value);           // Decimal output
    else if (csrno == 0x137) Serial.print(value, HEX); // Hex output
    else if (csrno == 0x138) {
        uint32_t ptr = value - MINIRV32_RAM_IMAGE_OFFSET;
        while (ptr < RAM_SIZE && image[ptr]) Serial.write(image[ptr++]);
    } else if (csrno == 0x139) Serial.write((char)value); // Single byte output
}


static int32_t HandleOtherCSRRead(uint8_t *image, uint16_t csrno) { //valid
    if (csrno == 0x140) return -1;
    return 0;
}
//end of emulator functions

void setup() {
      Serial.begin(9600);
  SPI.begin();
  pinMode(CS_PIN, OUTPUT);
  digitalWrite(CS_PIN, HIGH);

  delay(100);  // Let card settle

   

    Serial.println("Initializing SD card...");
    if (!initCard()) {
        Serial.println("SD card init failed.");
        while (1);  // Halt
    }
    Serial.println("SD card initialized.");
    delay(1000);
    Serial.println("Preloading DTB...");
    preloadDTB(MINIRV32_RAM_IMAGE_OFFSET + 0x1000);
    Serial.println("DTB loaded.");

    Serial.println("Setting up emulator...");
    core = (struct MiniRV32IMAState *)(ram_page + 512 - sizeof(struct MiniRV32IMAState));
    core->pc = 0x80000000;  // Start of payload (adjust if needed)
    core->regs[10] = 0;     // hartid
    core->regs[11] = MINIRV32_RAM_IMAGE_OFFSET + 0x1000;  // DTB pointer
    core->extraflags |= 3;  // Enable timer + MMU

    Serial.println("Starting emulation...");
    uint64_t lastTime = GetTimeMicroseconds();
    int instrs_per_flip = 1024;
    uint32_t total_instrs = 0;
    //
    uint32_t entry = 0x80000000;
   uint32_t sector = (entry - MINIRV32_RAM_IMAGE_OFFSET) / 512;
   //
    Serial.print("Preloading sector "); Serial.println(sector);
   if (!readSectorFromSD(sector, ram_page)) {
    Serial.println("Failed to load initial payload sector.");
    while (1);
   }
current_page = sector;
dirty = false;
    uint32_t pc = core->pc;
    uint32_t instr = *((uint32_t *)(ram_page + (pc - MINIRV32_RAM_IMAGE_OFFSET)));
    Serial.print("PC: 0x"); Serial.print(pc, HEX);
    Serial.print("  Instruction: 0x"); Serial.println(instr, HEX);

    while (1) {
        uint64_t currentTime = GetTimeMicroseconds();
        uint32_t elapsedUs = currentTime - lastTime;
        lastTime = currentTime;

        int ret = MiniRV32IMAStep(core, NULL, 0, elapsedUs, instrs_per_flip);
        total_instrs += instrs_per_flip;

        if (ret == 1) {
            *((uint64_t *)&core->cyclel) += instrs_per_flip;
        } else if (ret == 3 || ret == 0x5555) {
            Serial.println("Emulator halted.");
            break;
        }

        // Optional debug output every N instructions
       // if ((total_instrs % 32768) == 0) {
            //Serial.print("PC: 0x"); Serial.println(core->pc, HEX);
               uint32_t pc = core->pc;
                 uint32_t instr = *((uint32_t *)(ram_page + (pc - MINIRV32_RAM_IMAGE_OFFSET)));
               Serial.print("PC: 0x"); Serial.print(pc, HEX);
               Serial.print("  Instruction: 0x"); Serial.println(instr, HEX);
        //}
    }

    Serial.println("Done.");
    return 0;
}

void loop(){};